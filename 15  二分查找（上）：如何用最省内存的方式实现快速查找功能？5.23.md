## 15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？5.23

老规矩，我们还是来看一道思考题。

假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？带着这个问题，让我们进入今天的内容吧！

### 二分查找的思想

![二分查找](https://static001.geekbang.org/resource/image/8b/29/8bce81259abf0e9a06f115e22586b829.jpg)

**总结：二分查找针对的是一个有序的数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。**

### 二分查找的时间复杂度

假设数据大小是n,每次查找后数据都会缩小为原来的一半，也就是会除以2。最坏情况下，直到查找区间被缩小为空，就会停止。

![二分查找时间复杂度](https://static001.geekbang.org/resource/image/d1/94/d1e4fa1542e187184c87c545c2fe4794.jpg)

以看出来，这是一个等比数列。其中 n/2k=1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过 n/2k=1，我们可以求得 k=log2n，所以时间复杂度就是 O(logn)。

**二分查找时间复杂度为O(logn)，这是一种非常高效的时间复杂度，有时候甚至比时间复杂度为常量的O(1)的算法还要高效**

因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。

我们前面讲过，用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高

### 二分查找的代码实现

最简单的二分查找情况：**有序数组不存在重复元素**

```java
 /**
     * @param arr   数组
     * @param n     数组大小
     * @param value 要查找的值
     */
    public int binarySearch(int[] arr, int n, int value) {

        int low = 0;
        int high = n - 1;
        int mid;

        while (low <= high) {
            mid = low + ((high - low) >> 1);//防止high + low 发生溢出， 当两者都很大的时候
           // mid = (high + low) >> 1;//等效于除以2 但是位运算的效率更高
            if (arr[mid] == value) return mid;
            if (arr[mid] < value) low = mid + 1;
            if (arr[mid] > value) high = mid - 1;
        }

        return -1;
    }
```

**三个易错点**

1. 循环退出条件：low<= high
2. mid的取值：为了避免mid + low发生溢出 改写成 mid = low + ((high - low) >> 1)
3. low 和 high 跟新

```java

// 二分查找的递归实现
public int bsearch(int[] a, int n, int val) {
  return bsearchInternally(a, 0, n - 1, val);
}

private int bsearchInternally(int[] a, int low, int high, int value) {
  if (low > high) return -1;

  int mid =  low + ((high - low) >> 1);
  if (a[mid] == value) {
    return mid;
  } else if (a[mid] < value) {
    return bsearchInternally(a, mid+1, high, value);
  } else {
    return bsearchInternally(a, low, mid-1, value);
  }
}
```

### 二分查找应用场景的局限性

二分查找的时间复杂度非常好，但是同时他也有局限性

1. **二分查找依赖顺序表结构（依赖数组)**

   因为二分查找需要按照下标随机访问数据，所以只能在数组上实现。

2. **二分查找针对的是有序数据**

   适合一次排序，多次查找的场景使用。

3. **数据调小和数据太大都不适合二分查找**
   数据太小，二分查找和遍历的耗时差不多，没必要。如果数据量太大，由于二分查找需要连续的内存空间，需要连续的很大的内存空间，内存要求太高。

### 内容小结

今天我们学习了一种针对有序数据的高效查找算法，二分查找，它的时间复杂度是 O(logn)。

二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。

二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作