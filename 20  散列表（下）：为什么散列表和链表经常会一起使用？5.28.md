## 20 | 散列表（下）：为什么散列表和链表经常会一起使用？5.28

### LRU缓存淘汰算法

首先复习一下LRU算法，LRU算法就是删除最近不常用的缓存。如果只是通过单链表来实现，那么就需要维持一个链表，链表的末尾是最近访问的元素。当要缓存某个数据的时候，先从链表中查询，如果没有就将其加入到链表末尾（如果缓存没有满），如果存在就将原来的删除，然后将其加入到链表的末尾。如果缓存满了，就删除链表的开头的节点。这个我们发现如果要缓存数据，涉及到查询，删除，添加三个操作。其时间复杂度都是o(n)。

**但是如果采用散列表和链表结合的方式就能够将时间复杂度降低为o(1)**，具体结构如下图所示

![散列表和双向链表结合](https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg)

因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。

其实就是散列表中的每个数据同时又在一个双向链表中。这时候如果有一个数据要加入缓存，首先会进行查询，散列表的查询时间复杂度是o(1),如果存在那么要删除这个节点，由于是双向链表那么找到前置节点的时间复杂度是o(1),所以删除的时间复杂度是o(1),最后添加到末尾的时间复杂度也是O(1)。

综上，散列表和双向链表的结合实现了时间复杂度为O(1)的LRU缓存淘汰算法。

### Redis集合

在跳表那一节，讲到有序集合的操作时，我稍微做了些简化。实际上，在有序集合中，每个成员对象有两个重要的属性，key（键值）和 score（分值）。我们不仅会通过 score 来查找数据，还会通过 key 来查找数据。

举个例子，比如用户积分排行榜有这样一个功能：我们可以通过用户的 ID 来查找积分信息，也可以通过积分区间来查找用户 ID 或者姓名信息。这里包含 ID、姓名和积分的用户信息，就是成员对象，用户 ID 就是 key，积分就是 score。

所以，如果我们细化一下 Redis 有序集合的操作，那就是下面这样

- 添加一个成员对象；
- 按照键值来删除一个成员对象；
- 按照键值来查找一个成员对象；
- 按照分值区间查找数据，比如查找积分在[100, 356]之间的成员对象；
- 按照分值从小到大排序成员变量；

如果我们仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与 LRU 缓存淘汰算法的解决方法类似。我们可以再按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。同时，借助跳表结构，其他操作也非常高效。

### Java LinkedHashMap

LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。