## 11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？5.19

![内容介绍](https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg)

### 如何分析一个排序算法？（衡量一个排序算法是否合适）

从下面三个方面来分析一个排序算法

- **执行效率**

  1. 最好情况，最坏情况，平均情况时间复杂度：需要知道三种情况下的时间复杂度，并且知道最好最坏情况下的数据是什么样子的。因为我们在处理数据的时候会面对各种各样的数据情况。
  2. 时间复杂度的系数、常数、低阶。数据量可能没有很大，要把低阶的情况考虑进来。
  3. 比较次数和交换（或移动）次数：针对比较排序，就会涉及数据搬移，要将数据搬移的时间复杂度考虑进来。

- **内存消耗**

  空间复杂度是O(1)的排序算法，叫**原地排序**（Sorted in place)

- **稳定性**

  概念：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变.

  稳定性的作用举例：我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？

  解决方案：先按照时间排序，然后使用稳定排序按照金额排序。

  ![稳定性举例](https://static001.geekbang.org/resource/image/13/59/1381c1f3f7819ae61ab17455ed7f0b59.jpg)

  

### 冒泡排序（Bubble Sort)	

#### 冒泡排序的原理和实现

**传统的冒泡排序**

冒泡排序只会操作相邻的两个数据。每次冒泡都会对相邻的两个元素进行比较，满足大小关系，继续循环。不满足大小关系，交换数据继续进行循环。

![传统冒泡](https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg)

**优化的冒泡排序**

当某次冒泡操作没有数据交换的时候，表示整个数组已经是有序的，不需要再进行后续的冒泡了。

![优化的冒泡排序](https://static001.geekbang.org/resource/image/a9/e6/a9783a3b13c11a5e064c5306c261e8e6.jpg)

**代码实现**

```java
 public  void bubbleSort(int[] arr, int n) {

        boolean flag = false; //标记是否有数据交换

        for (int i = 0; i < n - 1; i++) {
           //一次冒泡的过程
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {//交换数据
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    flag = true; //有数据交换
                }
            }
            //判断本次冒泡过程是否有数据交换
            if(!flag) break;
        }

    }
```

#### 冒泡排序算法分析

- **内存消耗**

  是原地算法，空间复杂度为O(1)

- **稳定性**

  是稳定算法

- **算法效率**：

  采用"有序度"和”逆序度"概念，来评估交换数据的时间复杂度。总的平均时间复杂度等于比较时间复杂度和交换时间复杂度中大的那个，为O(n2)。

  当完全有序的时候，最好时间复杂度是O(n)

  当完全没有序的时候，最坏时间复杂度是O(n2)

### 插入排序（Insertion Sort)

#### 插入排序的原理和实现

**原理**

我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

![插入排序](https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg)

**代码实现**

```java
//插入排序 实现从小到大排序
public  void insertionSort(int[] arr, int n) {//n是数组的大小

    for (int i = 1; i < n; i++) {//表示要进行插入的次数 和要进行插入的坐标
        int value = arr[i];
        int j = i - 1;
        //查找插入的位置
        for (; j >= 0; j--) {
            if (arr[j] > value) {
                arr[j + 1] = arr[j];//向后移动
            } else {
                break;
            }
        }
        arr[j + 1] = value;
    }
}
```

#### 插入排序算法分析

- **内存消耗**

  没有多余的内存消耗 时间复杂度为O(1)

- **稳定性**

  是稳定排序算法

- **算法的效率**

  最好时间复杂度是O(n)，最坏时间复杂度和平均时间复杂度都是O(n2)

### 选择排序（Selection Sort）

#### 选择排序的原理和实现

**原理**

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![选择排序](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

**代码实现**

```java
public  void selectionSort(int[] arr, int n) {//n是数组大小

    for (int i = 0; i < n - 1; i++) {//要进行选择的次数
        int min = arr[i]; //最小值
        int pos = i; //一次选择的最小值的角标
        //找到最小值和其对应的角标
        for (int j = i; j < n; j++) {
            if (arr[j] < min) {
                min = arr[j];
                pos = j;
            }
        }
        //交换数据
        int temp = arr[pos];
        arr[pos] = arr[i];
        arr[i] = temp;
    }

}
```

#### 选择排序算法分析

- **内存消耗**

  原地算法，内存消耗为O(1)

- **稳定性**

  不是稳定算法，例如对5,8,5,2,9排序，那么两个5的前后位置就发生了改变

- **执行效率**

  最好，最坏和平均时间复杂度都是O(n2),所以相比较上面两种排序算法，选择排序要差劲一些。

### 解答开篇

我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：

```java

冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。

这个只是我们非常理论的分析，为了实验，针对上面的冒泡排序和插入排序的 Java 代码，我写了一个性能对比测试程序，随机生成 10000 个数组，每个数组中包含 200 个数据，然后在我的机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约 700ms 才能执行完成，而插入排序只需要 100ms 左右就能搞定！

### 内容小结

重点掌握排序算法的分析放法，包含**执行效率**，**内存消耗**和**稳定性**，学会分析。

介绍了下面三种排序方法，都需要回写，其中插入排序要重点掌握，后面还会用到，要烂熟于心。

![排序算法对比](https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg)